"""
Custom Transform Pipeline for VideoMAE Training

This module provides transform pipelines for video preprocessing, normalization,
and masking generation for EVEREST VideoMAE training.
"""

import torch
import torch.nn as nn
import numpy as np
from masking_generator import TubeMaskingGenerator, RandomMaskingGenerator
import random
from torchvision.transforms.v2 import Normalize, RandomResizedCrop, Compose


class DataAugmentationForVideoMAE(object):
    """
    Data augmentation and masking pipeline for VideoMAE training.
    
    This class handles:
    - Video normalization with custom mean/std
    - Masking generation (random, tube, or motion-centric)
    - Integration with VideoMAE model's masking requirements
    
    Args:
        normalize_mean (list): Mean values for normalization [R, G, B]
        normalize_std (list): Standard deviation values for normalization [R, G, B]
        window_size (tuple): Window size for masking (frames, height_patches, width_patches)
        mask_type (str): Type of masking - 'random', 'tube', or 'motion-centric'
        mask_ratio (float): Ratio of patches to mask
        motion_centric_masking_ratio (float): Ratio for motion-centric masking (if applicable)
    """
    
    def __init__(
        self,
        normalize_mean=[0.117, 0.114, 0.113],
        normalize_std=[0.208, 0.204, 0.203],
        window_size=(8, 14, 14),  # (frames, height_patches, width_patches)
        mask_type='motion-centric',
        mask_ratio=0.9,
        motion_centric_masking_ratio=0.7,
        crop_scale=(0.75,1.0),
        crop_aspect_ratio=(0.8,1.2),
        frame_size=224
    ):
        self.normalize_mean = normalize_mean
        self.normalize_std = normalize_std
        self.window_size = window_size
        self.mask_type = mask_type
        self.mask_ratio = mask_ratio
        self.motion_centric_masking_ratio = motion_centric_masking_ratio
        
        # Initialize normalizer
        self.normalizer = Normalize(normalize_mean, normalize_std)
        self.train_augmentation = RandomResizedCrop(size=frame_size, scale=crop_scale, ratio=crop_aspect_ratio)
        self.transform = Compose([
            self.train_augmentation,
            self.normalizer
            ])
        
        # Initialize masking generator based on mask type
        self.mcm = False  # Motion-centric masking flag
        if mask_type == 'tube':
            self.masked_position_generator = TubeMaskingGenerator(
                window_size, mask_ratio
            )
        elif mask_type == 'random':
            self.masked_position_generator = RandomMaskingGenerator(
                window_size, mask_ratio
            )
        elif mask_type == 'motion-centric':
            # Motion-centric masking is handled by the model itself
            self.mcm = True
            self.masked_position_generator = 'Motion-centric Masking'
        else:
            raise ValueError(f"Unknown mask_type: {mask_type}. Must be 'random', 'tube', or 'motion-centric'")
    
    def __call__(self, video):
        """
        Apply transforms to video.
        
        Args:
            video (torch.Tensor): Video tensor of shape [C, T, H, W]
            
        Returns:
            tuple: (normalized_video, mask) where:
                - normalized_video: Normalized video tensor [C, T, H, W]
                - mask: Mask tensor or None (for motion-centric, mask is generated by model)
        """

        # Normalize video
        normalized_video = self.transform(video)
        
        # Generate mask if not motion-centric
        if self.mcm:
            # Motion-centric masking is handled by the model
            # Return 0 as placeholder (model will generate mask internally)
            return normalized_video.permute(1,0,2,3), 0
        return normalized_video.permute(1,0,2,3), self.masked_position_generator()      
    
    def __repr__(self):
        """String representation of the transform."""
        repr_str = "DataAugmentationForVideoMAE(\n"
        repr_str += f"  normalize_mean={self.normalize_mean},\n"
        repr_str += f"  normalize_std={self.normalize_std},\n"
        repr_str += f"  window_size={self.window_size},\n"
        repr_str += f"  mask_type={self.mask_type},\n"
        repr_str += f"  mask_ratio={self.mask_ratio},\n"
        if self.mcm:
            repr_str += f"  motion_centric_masking_ratio={self.motion_centric_masking_ratio}\n"
        repr_str += ")"
        return repr_str

